<!DOCTYPE html>
<!-- saved from url=(0044)https://bwip-js.metafloor.com/demo/demo.html -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<title>SteveHere's bwip-js Barcode Generator fork</title>
		<meta name="keywords" content="bar code, barcode generator, online barcode generator, free barcode generator, javascript, javascript library, nodejs, QR Code, EAN, EAN 13, Code 128, UPC, ISBN, ITF 14, Code 39, GS1, GS1 128, PDF417, HIBC, DataMatrix, Data Matrix, DataBar, OCR, OCR B, OCR font, Aztec Code, PostNet, USPS, Pharmacode">
		<meta name="description" content="JavaScript barcode generator and library.  Create any barcode in your browser.">

		<link rel="preload" href="./bwip-js_files/bwip-js-min.js" as="script" />
		<link rel="preload" href="./bwip-js_files/fontLoader.js" as="script" />
		<link rel="preload" href="./bwip-js_files/drawing-svg.js" as="script" />
		<link rel="preload" href="./bwip-js_files/barcodeTypeOptions.js" as="script" />

		<script type="text/javascript" src="./bwip-js_files/bwip-js-min.js"></script>
		<script type="text/javascript">
			// file: bwip-js/lib/symdesc.js
			//
			// This code was automatically generated from:
			// Barcode Writer in Pure PostScript - Version 2021-02-06
			//
			// Copyright (c) 2011-2021 Mark Warren
			// Copyright (c) 2004-2021 Terry Burton
			//
			// Licensed MIT.  See the LICENSE file in the bwip-js root directory
			// for the extended copyright notice.
			var symdesc = {
				"ean5":								"EAN-5 (5 digit addon)",
				"ean2":								"EAN-2 (2 digit addon)",
				"ean13":							"EAN-13",
				"ean8":								"EAN-8",
				"upca":								"UPC-A",
				"upce":								"UPC-E",
				"isbn":								"ISBN",
				"ismn":								"ISMN",
				"issn":								"ISSN",
				"code128":							"Code 128",
				"gs1-128":							"GS1-128",
				"ean14":							"GS1-14",
				"sscc18":							"SSCC-18",
				"code39":							"Code 39",
				"code39ext":						"Code 39 Extended",
				"code32":							"Italian Pharmacode",
				"pzn":								"Pharmazentralnummer (PZN)",
				"code93":							"Code 93",
				"code93ext":						"Code 93 Extended",
				"interleaved2of5":					"Interleaved 2 of 5 (ITF)",
				"itf14":							"ITF-14",
				"identcode":						"Deutsche Post Identcode",
				"leitcode":							"Deutsche Post Leitcode",
				"databaromni":						"GS1 DataBar Omnidirectional",
				"databarstacked":					"GS1 DataBar Stacked",
				"databarstackedomni":				"GS1 DataBar Stacked Omnidirectional",
				"databartruncated":					"GS1 DataBar Truncated",
				"databarlimited":					"GS1 DataBar Limited",
				"databarexpanded":					"GS1 DataBar Expanded",
				"databarexpandedstacked":			"GS1 DataBar Expanded Stacked",
				"gs1northamericancoupon":			"GS1 North American Coupon",
				"pharmacode":						"Pharmaceutical Binary Code",
				"pharmacode2":						"Two-track Pharmacode",
				"code2of5":							"Code 25",
				"industrial2of5":					"Industrial 2 of 5",
				"iata2of5":							"IATA 2 of 5",
				"matrix2of5":						"Matrix 2 of 5",
				"coop2of5":							"COOP 2 of 5",
				"datalogic2of5":					"Datalogic 2 of 5",
				"code11":							"Code 11",
				"bc412":							"BC412",
				"rationalizedCodabar":				"Codabar",
				"onecode":							"USPS Intelligent Mail",
				"postnet":							"USPS POSTNET",
				"planet":							"USPS PLANET",
				"royalmail":						"Royal Mail 4 State Customer Code",
				"auspost":							"AusPost 4 State Customer Code",
				"kix":								"Royal Dutch TPG Post KIX",
				"japanpost":						"Japan Post 4 State Customer Code",
				"msi":								"MSI Modified Plessey",
				"plessey":							"Plessey UK",
				"telepen":							"Telepen",
				"telepennumeric":					"Telepen Numeric",
				"posicode":							"PosiCode",
				"codablockf":						"Codablock F",
				"code16k":							"Code 16K",
				"code49":							"Code 49",
				"channelcode":						"Channel Code",
				"flattermarken":					"Flattermarken",
				"raw":								"Custom 1D symbology",
				"daft":								"Custom 4 state symbology",
				"symbol":							"Miscellaneous symbols",
				"pdf417":							"PDF417",
				"pdf417compact":					"Compact PDF417",
				"micropdf417":						"MicroPDF417",
				"datamatrix":						"Data Matrix",
				"datamatrixrectangular":			"Data Matrix Rectangular",
				"datamatrixrectangularextension":	"Data Matrix Rectangular Extension",
				"mailmark":							"Royal Mail Mailmark",
				"qrcode":							"QR Code",
				"swissqrcode":						"Swiss QR Code",
				"microqrcode":						"Micro QR Code",
				"rectangularmicroqrcode":			"Rectangular Micro QR Code",
				"maxicode":							"MaxiCode",
				"azteccode":						"Aztec Code",
				"azteccodecompact":					"Compact Aztec Code",
				"aztecrune":						"Aztec Runes",
				"codeone":							"Code One",
				"hanxin":							"Han Xin Code",
				"dotcode":							"DotCode",
				"ultracode":						"Ultracode",
				"gs1-cc":							"GS1 Composite 2D Component",
				"ean13composite":					"EAN-13 Composite",
				"ean8composite":					"EAN-8 Composite",
				"upcacomposite":					"UPC-A Composite",
				"upcecomposite":					"UPC-E Composite",
				"databaromnicomposite":				"GS1 DataBar Omnidirectional Composite",
				"databarstackedcomposite":			"GS1 DataBar Stacked Composite",
				"databarstackedomnicomposite":		"GS1 DataBar Stacked Omnidirectional Composite",
				"databartruncatedcomposite":		"GS1 DataBar Truncated Composite",
				"databarlimitedcomposite":			"GS1 DataBar Limited Composite",
				"databarexpandedcomposite":			"GS1 DataBar Expanded Composite",
				"databarexpandedstackedcomposite":	"GS1 DataBar Expanded Stacked Composite",
				"gs1-128composite":					"GS1-128 Composite",
				"gs1datamatrix":					"GS1 Data Matrix",
				"gs1datamatrixrectangular":			"GS1 Data Matrix Rectangular",
				"gs1qrcode":						"GS1 QR Code",
				"gs1dotcode":						"GS1 DotCode",
				"hibccode39":						"HIBC Code 39",
				"hibccode128":						"HIBC Code 128",
				"hibcdatamatrix":					"HIBC Data Matrix",
				"hibcdatamatrixrectangular":		"HIBC Data Matrix Rectangular",
				"hibcpdf417":						"HIBC PDF417",
				"hibcmicropdf417":					"HIBC MicroPDF417",
				"hibcqrcode":						"HIBC QR Code",
				"hibccodablockf":					"HIBC Codablock F",
				"hibcazteccode":					"HIBC Aztec Code"
			};
		</script>
		<script type="text/javascript" src="./bwip-js_files/fontLoader.js"></script>
		<script type="text/javascript" src="./bwip-js_files/drawing-svg.js"></script>
		<script type="text/javascript" src="./bwip-js_files/barcodeTypeOptions.js"></script>
		<script type="text/javascript">
			const gbID =(x)=>document.getElementById(x);
			let triggerDownload = (imgURI, fileName) => {
				(a=>{a.click()})(Object.assign(document.createElement('a'), { 'download': fileName, 'href': imgURI }))
			}

			const getsRGB = c => (x=>((x <= 0.03928) ? x / 12.92 : Math.pow(((x + 0.055) / 1.055), 2.4)))(parseInt(c, 16) / 255);
			const getL = c => (0.2126 * getsRGB(c[0]+c[1]) + 0.7152 * getsRGB(c[2]+c[3]) + 0.0722 * getsRGB(c[4]+c[5]));
			const getLRatio = (fg, bg) => ((fgl, bgl)=>(Math.max(fgl, bgl) + 0.05) / (Math.min(fgl, bgl) + 0.05))(getL(fg), getL(bg));

			function saveCanvas(type, ext) {
				let barcodeSVG = gbID('svgTarget').firstElementChild.cloneNode(true);
	            // if(id("transparent").checked) avatar.getElementById("background-color").style.opacity = 0;

	            let svgBlob = new Blob([(new XMLSerializer()).serializeToString(barcodeSVG)], {type: 'image/svg+xml;charset=utf-8'});
	  			let img = new Image();
	            img.onload = ()=>{ 
	            	let canvas = document.createElement("canvas");
	                canvas.width=barcodeSVG.width.baseVal.value; canvas.height=barcodeSVG.height.baseVal.value;
	                let ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0);
	                triggerDownload(canvas.toDataURL(type), saveCanvas.basename + ext);
	            };
	            img.setAttribute("src", URL.createObjectURL(svgBlob));
			}
			
			function saveSVG() {
				triggerDownload(URL.createObjectURL(new Blob([gbID('svgTarget').innerHTML], {type: "image/svg+xml"})), `${saveCanvas.basename}.svg`);
			}
			

			function setURL(opts) {
				let args = [];
				for (const [key, value] of Object.entries(opts)) {
					if (key === 'bcid') continue;
					if (['includecheck', 'includetext', 'includecheckintext'].includes(key)){
						if(value){ args.push(key); }
					} else {
						args.push(`${key}=${['text', 'alttext'].includes(key) ? encodeURIComponent(value) : value}`);
					}
				}
				gbID('apiurl').href = `https://bwipjs-api.metafloor.com/?bcid=${opts['bcid']}&${args.join('&')}`;
			}

			window.writeToLog = (text, error=false)=>{
				let log = gbID('logArea')
				log.append(
					Object.assign(document.createElement('span'), {
						textContent: `${(new Date()).toLocaleTimeString('en-US', { hour12: false })} - ${text}`,
						...(error && { 'className': 'loggederror' }),
					}),
					document.createElement('br')
				)
				log.scrollTo(0, log.scrollHeight);
			};

			function render() {
				let settings = {
					symbol: gbID('symbol').value,
					version: gbID('barcodeTypeOptions').value,
					text: gbID('symtext').value.trim(),
					alttext: gbID('symaltx').value.trim(),
					rotate: document.querySelector('input[name="rotate"]:checked').value,
					scaleX: +gbID('scaleX').value || 2,
					scaleY: +gbID('scaleY').value || 2,
					fontType: gbID('barcodeTextFontType').value,
					fontSize: gbID('textSize').value,
					includeCheck: gbID('includeCheck').checked,
					includeText: gbID('includeText').checked,
					includeCheckInText: gbID('includeCheckInText').checked,
					miscOptions: gbID('symopts').value.trim(),
					SVGRenderWithOnlyIntegers: gbID('SVGRenderWithOnlyIntegers').checked,
					fgColor: gbID('fgcolor').value.substr(1),
					bgColor: gbID('bgcolor').value.substr(1),
					transparentBG: gbID('transparentBG').checked,
					padding: gbID('padding').value
				}

				localStorage.setItem('bwipjsLastSettings', JSON.stringify(settings));

				// Clear the page
				gbID('saveas').style.visibility = 'hidden';
				gbID('svgTarget').innerHTML = '';
				gbID('svgTarget').setAttribute('transparentBG', settings.transparentBG);

				// These opts already exist & will always be present (unless the DOM's been tampered)
				let mandated_flags = {
					'text': settings.text,
					'alttext': settings.alttext,
					'bcid': settings.symbol,
					'scaleX': settings.scaleX,
					'scaleY': settings.scaleY,
					'rotate': settings.rotate,
					'textfont': settings.fontType,
					'textsize': settings.fontSize,
					'barcolor': settings.fgColor,
					'textcolor': settings.fgColor,
					'padding': settings.padding,

					...((settings.version !== "(auto)") && {'version': settings.version}),
					...((document.querySelector('#barcodeTypeOptions option:checked').parentElement.label !== undefined) && {
						'format': document.querySelector('#barcodeTypeOptions option:checked').parentElement.label.split(": ")[1]
					}),
					...(!settings.transparentBG && {'backgroundcolor': settings.bgColor}),
					...(settings.includeCheck && {'includecheck': settings.includeCheck}),
					...(settings.includeText && {'includetext': settings.includeText}),
					...(settings.includeCheckInText && {'includecheckintext': settings.includeCheckInText}),
				}

				// Convert the misc options to an object.
				let miscOpts = {};
				for (const opt of settings.miscOptions.split(/\s+/)) {
					let parts = opt.split('=');
					if (parts[0] === 'backgroundcolor') continue;
					if (parts[0] === 'includecheck') continue;
					if (parts[0] === 'includetext') continue;
					if (parts[0] === 'includecheckintext') continue;

					if (parts.length == 1) {
						miscOpts[parts[0]] = true;
					} else {
						miscOpts[parts[0]] = parts[1];
					}
				}

				const opts = {...miscOpts, ...mandated_flags};

				// Draw the bar code to the canvas
				try {
					const ts0 = performance.now();
					let clonedOpts = Object.assign({}, opts);
					const svgResult = bwipjs.render(clonedOpts, window.DrawingSVG(clonedOpts, window.bwipjs.FontLib, settings.SVGRenderWithOnlyIntegers));
					gbID('svgTarget').innerHTML = svgResult;

					const LRatio = getLRatio(settings.fgColor, settings.bgColor);
					gbID('LRatio').textContent = LRatio.toFixed(3);

					gbID('AAThin').setAttribute('data-content', (LRatio >= 4.5) ? "pass" : "fail");
					gbID('AAThick').setAttribute('data-content', (LRatio >= 3) ? "pass" : "fail");
					gbID('AAAThin').setAttribute('data-content', (LRatio >= 7) ? "pass" : "fail");
					gbID('AAAThick').setAttribute('data-content', (LRatio >= 4.5) ? "pass" : "fail");
					gbID('AAInput').setAttribute('data-content', (LRatio >= 3) ? "pass" : "fail");

					show(ts0, performance.now(), opts);
				} catch (e) {
					// Watch for BWIPP generated raiseerror's.
					let msg = ('' + e).trim();
					if (msg.indexOf("bwipp.") >= 0) {
						window.writeToLog(msg, true);
					} else if (e.stack) {
						// GC includes the message in the stack.  FF does not.
						window.writeToLog((e.stack.indexOf(msg) == -1 ? msg + '\n' : '') + e.stack, true);
					} else {
						window.writeToLog(msg, true);
					}
					throw e;
				}

				function show(ts0, ts1, opts) {
					setURL(opts);
					window.writeToLog(`Barcode rendered in ${(ts1 - ts0).toFixed(3)} msecs`);
					gbID('saveas').style.visibility = 'visible';
					saveCanvas.basename = opts.bcid + '-' + opts.text.split("\n")[0].replace(/[^a-zA-Z0-9._]+/g, '-');
				}
			}
			
			window.addEventListener('load', function() { 
				// Set up the select list of barcode types
				{
					let opts = Object.entries(symdesc);
					opts.sort(function(a, b) { return a[1] < b[1] ? -1 : 1 });
					gbID('symbol').append(...opts.map(opt=>new Option(opt[1], opt[0])));
				}
				
				gbID('symbol').addEventListener('change', function(ev) {
					gbID('saveas').style.visibility = 'hidden';
					console.log(ev.target.value)
					window.changeBarcodeOptions(gbID('barcodeTypeOptions'), ev.target.value);
					render();
				});

				function dTh(val){ return (val).toString(16).padStart(2, '0'); }
				
				gbID('scaleX').addEventListener('change', function(ev) { gbID('scaleY').value = ev.target.value; });
				gbID('render').addEventListener('click', render);
				gbID('autoAAABarcodeColor').addEventListener('click', function(ev) {
					ev.target.disabled = true;

					setTimeout(()=>{
						let ts0 = performance.now();

						// Goal: Calculate color with min L ratio of 7
						let bgC = gbID('bgcolor').value.substr(1);
						let bgL = getL(bgC);
						const min_L_ratio = 5, AAA_ratio = 7;

						let fgCElement = gbID('fgcolor');
						let possible_rgbs = [];
						const step = 4;

						// Brute force is the easiest understandable solution towards finding the fg color
						// Number of iterations: (int(255/step))^3
						// At step = 4, search space is computable in ~300ms. 
						for (let r = 0; r <= 255; r += step){
							for (let g = 0; g <= 255; g += step){
								for (let b = 0; b <= 255; b += step){
									const fgC = `${dTh(r)}${dTh(g)}${dTh(b)}`;
									const fgL = getL(fgC);
									const LRatio = (Math.max(fgL, bgL) + 0.05) / (Math.min(fgL, bgL) + 0.05);
									if (LRatio >= min_L_ratio) {
										possible_rgbs.push([fgC, LRatio]);
									}
								}
							}
						}

						if (possible_rgbs.some(e=>e[1] >= AAA_ratio)){
							writeToLog("Using guessed AAA-compliant color that achieves minimum luminance contrast ratio");
							let AAA = possible_rgbs.filter(e=>e[1] >= AAA_ratio);
							fgCElement.value = `#${AAA[(Math.random()*AAA.length)|0][0]}`;
						} else if (possible_rgbs.some(e=>e[1] >= 6)){
							writeToLog("Unable to find AAA-compliant color - Using colors with minimum LCR >= 6");
							let al6 = possible_rgbs.filter(e=>e[1] >= 6);
							fgCElement.value = `#${al6[(Math.random()*al6.length)|0][0]}`;
						} else if (possible_rgbs.length > 0) {
							writeToLog("Unable to find AAA-compliant color - Using colors with minimum LCR >= 5");
							fgCElement.value = `#${possible_rgbs[(Math.random()*possible_rgbs.length)|0][0]}`;
						} else {
							writeToLog("Unable to find AAA-compliant color - Defaulting to black/white");
							fgCElement.value = `#${getLRatio('000000', bgC) > getLRatio('FFFFFF', bgC) ? '000000' : 'FFFFFF'}`;
						}

						writeToLog(`Computed fg color guess in ${ (performance.now() - ts0).toFixed(3) } ms`);
						ev.target.disabled = false;

						render();
					}, 0);
				});

				gbID('autoComplementaryBarcodeColor').addEventListener('click', function(ev) {
					ev.target.disabled = true;

					const hti=(hex)=>parseInt(hex, 16);
					const hexToRGB=(hex = "#000000")=>[hti(hex[1] + hex[2]), hti(hex[3] + hex[4]), hti(hex[5] + hex[6])];
					function RGBtoHSL(r = 0, g = 0, b = 0){ r /= 255, g /= 255, b /= 255;
						let max=Math.max(r,g,b), min=Math.min(r,g,b); let d=max-min, l2=max+min; // l2 = lightness * 2 

						if (max == min) return { h: 0, s: 0, l: l2/2 }; // h = [0-1], s = [0-1], l = [0-1]
						return {h:{[r]:(g-b)/d+(g<b?6:0), [g]:(b-r)/d+2, [b]:(r-g)/d+4}[max]/6, s:d/(l2>1?(2-l2):l2), l:l2/2 } 
					}

					function hue2rgb(p, q, t) {
						t = (t < 0) ? t + 1 : ((t > 1) ? t - 1 : t );
						if (t < 1/6) return p + (q - p) * 6 * t;
						if (t < 1/2) return q;
						if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
						return p;
					}

					function hslToRgb(h = 0, s = 0, l = 0) { // h = [0-1], s = [0-1], l = [0-1]
						// r = [0-255], g = [0-255], b = [0-255]
						if (s == 0) return [ (l * 255)|0, (l * 255)|0, (l * 255)|0 ]; 

						const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
						const p = 2 * l - q;
						return [ 
							(hue2rgb(p, q, h + 1/3) * 255)|0,  (hue2rgb(p, q, h) * 255)|0,  (hue2rgb(p, q, h - 1/3) * 255)|0
						];
					}

					setTimeout(()=>{
						let ts0 = performance.now();

						// Goal: Calculate color with min L ratio of 7
						let bgRGBHex = gbID('bgcolor').value.substr(1);
						let bgRGB = hexToRGB(gbID('bgcolor').value);
						let bgHSL = RGBtoHSL(bgRGB[0], bgRGB[1], bgRGB[2]);
						let fgH = (bgHSL.h + 0.5) % 1;

						const min_L_ratio = 5;

						let fgCElement = gbID('fgcolor');

						let LValues = [];
						for(let fgl = 0; fgl <= 100; fgl++){
							const fgRGBHex = (x=>`${dTh(x[0])}${dTh(x[1])}${dTh(x[2])}`)(hslToRgb(fgH, bgHSL.s, Math.min(1, fgl * 0.01)));
							const lratio = getLRatio(fgRGBHex, bgRGBHex);
							if(lratio > 4){ LValues.push([fgRGBHex, lratio]); }
						}
						
						if (LValues.some(v=>v[1] >= min_L_ratio)) {
							let LValuesT = LValues.filter(v=>v[1] >= min_L_ratio);
							fgCElement.value = `#${LValuesT[(Math.random()*LValuesT.length)|0][0]}`;
						} else {
							// LCR = (Math.max(fgl, bgl) + 0.05) / (Math.min(fgl, bgl) + 0.05)
							// fgl & bgl range := [0, 1]
							// fgl > bgl |=> LCR = (fgl + 0.05) / (bgl + 0.05)
							// 			 |=> LCR * bgl + (LCR - 1) * 0.05 = fgl 
							//			 | ( ( 1.05 - 0.05 * LCR ) / LCR > bgl)
							// bgl > fgl |=> LCR = (bgl + 0.05) / (fgl + 0.05)
							// 			 |=> LCR * fgl + (LCR - 1) * 0.05 = bgl
							//			 |=> fgl = (bgl - ((LCR - 1) * 0.05)) / LCR
							//			 | ( bgl > ((LCR - 1) * 0.05) )
							// (LCR = X) |=> ( 1.05 - 0.05 * X ) / X = ((X - 1) * 0.05)
							// 			 |=> 1.05 - 0.05 * X = 0.05*X*X - 0.05*X
							//			 |=> sqrt(1.05/0.05) = X ~ 4.58257569495584
							writeToLog(`Unable to find HSL with LCR >= 5: Finding min HSL with LCR >= 4.58`);
							let LValuesT = LValues.filter(v=>v[1] >= 4.58);
							fgCElement.value = `#${LValuesT[(Math.random()*LValuesT.length)|0][0]}`;
						}

						writeToLog(`Computed complementary fg color in ${ (performance.now() - ts0).toFixed(3) } ms`);
						ev.target.disabled = false;

						render();
					}, 0);
				});

				gbID('fontLoadForm').addEventListener('submit', async function (ev) {
					ev.preventDefault();
					try {
						const fontname = gbID('fontname').value;
						if ([...gbID('barcodeTextFontType').options].some(e=>e.textContent.toUpperCase()===fontname.toUpperCase() || e.value.toUpperCase()===fontname.toUpperCase())){
							writeToLog("Cannot load font - font name has already been used.", true);
						} else {
							const buffer = await gbID('fontfile').files[0].arrayBuffer();
							window.bwipjs.loadFont(fontname, buffer);

							gbID('barcodeTextFontType').append(new Option(fontname, fontname));
							writeToLog(`Font '${fontname}' loaded.`);
						}
					} catch (e) {
						// Watch for BWIPP generated raiseerror's.
						let msg = ('' + e).trim();
						if (e.stack) {
							// GC includes the message in the stack.  FF does not.
							window.writeToLog((e.stack.indexOf(msg) == -1 ? msg + '\n' : '') + e.stack, true);
						} else {
							window.writeToLog(msg, true);
						}
					}
				});
				gbID('saveas').style.visibility = 'hidden';

				// Allow Enter to render
				gbID('params').addEventListener('keypress', function(ev) { if (ev.which == 13) { render(); ev.stopPropagation(); ev.preventDefault(); return false; } });

				gbID('versions').textContent = 'bwip-js ' + bwipjs.BWIPJS_VERSION + ' / BWIPP ' + bwipjs.BWIPP_VERSION;

				document.addEventListener('change', function(ev){ 
					if(!['symtext', 'symaltx', 'symbol'].includes(ev.target.id)){
						render(); 
					}
				});
				gbID('symtext').addEventListener('input', function (ev) { 
					if(ev.target.value.length === 0){ ev.target.value = "12345"; }
					render(); ev.stopPropagation(); ev.preventDefault(); return false; 
				});
				gbID('symaltx').addEventListener('input', function (ev) { render(); ev.stopPropagation(); ev.preventDefault(); return false; });

				window.fontLoaderLoop = setInterval(window.fontLoader, 100);
				window.savedDataLoader = setInterval(function() {
					if(window.fontLoadComplete === true){
						let element = gbID("symtext");

					    function pasteIntoInput(el, text) {
					        el.focus();
					        if (typeof el.selectionStart == "number" && typeof el.selectionEnd == "number") {
					            let val = el.value, selStart = el.selectionStart;
					            el.value = val.slice(0, selStart) + text + val.slice(el.selectionEnd);
					            el.selectionEnd = el.selectionStart = selStart + text.length;
					        } else if (typeof document.selection != "undefined") {
					            let textRange = document.selection.createRange();
					            textRange.text = text;
					            textRange.collapse(false);
					            textRange.select();
					        }
					    }

					    function handleEnter(evt) {
					        let insert = ({13: '\n', 9: '\t'})[evt.keyCode];
					        if (insert !== undefined){ pasteIntoInput(evt.target, insert); evt.preventDefault(); }
					    }
					    element = gbID("symtext");
					    // Handle both keydown and keypress for Opera, which only allows default
					    // key action to be suppressed in keypress
					    element.addEventListener('keydown', handleEnter);
					    element.addEventListener('keypress', handleEnter);

						var saved;
						try { saved = JSON.parse(localStorage.getItem('bwipjsLastSettings')); } catch (e) { console.error(e); }

					    if (saved) {
							if (saved.symbol) { gbID('symbol').value = saved.symbol; } else { gbID('symbol').value = "qrcode"; }
							window.changeBarcodeOptions(gbID('barcodeTypeOptions'),  gbID('symbol').value);
							if (saved.version) { gbID('barcodeTypeOptions').value = saved.version; }
							if (saved.text) { gbID('symtext').value = saved.text; }
							if (saved.alttext) { gbID('symaltx').value = saved.alttext; }
							if (saved.scaleX && saved.scaleY) { gbID('scaleX').value = saved.scaleX; gbID('scaleY').value = saved.scaleY; }
							if (saved.rotate) { gbID('rotate' + saved.rotate).checked = true; }
							if (saved.fontType) { 
								if([...gbID('barcodeTextFontType').options].some(e=>e.value === saved.fontType)){
									gbID('barcodeTextFontType').value = saved.fontType; 
								} else {
									gbID('barcodeTextFontType').value = "OCR-A";
								}
							}
							if (saved.fontSize) { gbID('textSize').value = saved.fontSize; }
							if (saved.includeCheck) { gbID('includeCheck').checked = saved.includeCheck; }
							if (saved.includeText) { gbID('includeText').checked = saved.includeText; }
							if (saved.includeCheckInText) { gbID('includeCheckInText').checked = saved.includeCheckInText; }
							if (saved.miscOptions) { gbID('symopts').value = saved.miscOptions; }
							if (saved.SVGRenderWithOnlyIntegers) { gbID('SVGRenderWithOnlyIntegers').checked = saved.SVGRenderWithOnlyIntegers; }
							if (saved.padding) { gbID('padding').value = saved.padding; }

							if (saved.fgColor) { gbID('fgcolor').value = `#${saved.fgColor}`; }
							if (saved.bgColor) { gbID('bgcolor').value = `#${saved.bgColor}`; }
							if (saved.transparentBG) {  gbID('transparentBG').checked = saved.transparentBG; }
						} else {
							gbID('symbol').value = "qrcode";
							window.changeBarcodeOptions(gbID('barcodeTypeOptions'),  gbID('symbol').value);
						}

					    try {
					    	if(saved){ render(); }
							else { gbID('symtext').value = "example"; render(); }
					    } catch (e) {
					    	writeToLog("Unable to render saved barcode params", true);
					    	console.error(e);
					    }
					    clearInterval(window.savedDataLoader);
					    writeToLog("Cleared saved data loader loop");
					} else { writeToLog("Fonts not loaded in yet - Relooping"); }
				}, 200);
			});

			
		</script>
	</head>

	<body>
		<div id="header"> 
			<div id="bwip-js">bwip-js // Barcode Writer in Pure JavaScript <a href="https://github.com/SteveHere/bwip-js-online" target="_blank">(SteveHere's fork)</a></div> 
			<div id="versions"></div>
		</div>
		<div id="params">
			<table border="0" cellpading="0" cellspacing="0">
				<tbody>
					<tr>
						<td style="vertical-align:top;">
							<table border="0" cellpading="0" cellspacing="0" id="mainparams">
								<tbody>
									<tr>
										<th>Barcode Type:</th>
										<td colspan="5"><select id="symbol"></select></td>
										<th>Version:</th>
										<td><select id="barcodeTypeOptions"></select></td>
									</tr>
									<tr>
										<th>Bar Text:</th>
										<td colspan="7"><textarea id="symtext" type="text"></textarea></td>
									</tr>
									<tr>
										<th>Alt Text:</th>
										<td colspan="7"><input id="symaltx" type="text"></td>
									</tr>
									<tr>
										<th>Font Type:</th>
										<td colspan="2"><select id="barcodeTextFontType"></select></td>
										<th>Font Size:</th>
										<td><input id="textSize" type="number" value="10" min="1"></td>
										<th  colspan="2">Padding:</th>
										<td><input type="number" id="padding" value="1" min="0" step="1" max="10"></td>
									</tr>
									<tr>
										<th>Barcode & Text color:</th>
										<td colspan="2"><input type="color" id="fgcolor" value="#000000" /></td>
										<th>Background color:</th>
										<td><input type="color" id="bgcolor" value="#ffffff" /></td>
										<th colspan="2"><label for="transparentBG">Generate with transparent background:</label></th>
										<td><input type="checkbox" name="transparentBG" id="transparentBG" /></td>
									</tr>
									<tr>
										<th><label for="includeCheck">Include check:</label></th>
										<td colspan="2"><input type="checkbox" name="includeCheck" id="includeCheck" /></td>
										<th><label for="includeText">Include text:</label></th>
										<td><input type="checkbox" name="includeText" id="includeText" /></td>
										<th colspan="2"><label for="includeCheckInText">Include check in text:</label></th>
										<td><input type="checkbox" name="includeCheckInText" id="includeCheckInText" /></td>
									</tr>
									<tr>
										<th>Options:</th>
										<td colspan="7"><textarea id="symopts" type="text"></textarea></td>
									</tr>
									<tr>
										<td></td>
										<td colspan="7">
											<div id="saveas" style="visibility: hidden;">
												<a class="saveas" href="javascript:saveSVG()">Save As SVG</a>
												&nbsp;&nbsp;
												<a class="saveas" href="javascript:saveCanvas('image/png','.png')">Save As PNG</a>
												&nbsp;&nbsp;
												<a class="saveas" href="javascript:saveCanvas('image/jpeg','.jpg')">Save As JPEG</a>
												&nbsp;&nbsp;
												<a class="saveas" id="apiurl" href="">Goto URL</a>
												&nbsp;&nbsp;
											</div>
										</td>
									</tr>
									<tr>
										<td colspan="8"><div id="content"><div id="svgTarget"></div></div></td>
								</tbody>
							</table>
						</td>
						<td style="vertical-align:top;">
							<table border="0" cellpading="0" cellspacing="5">
								<tbody>
									<tr>
										<th>Scale X,Y:</th>
										<td>
											<input type="number" min="1" max="9" step="1" id="scaleX" value="2">
											<input type="number" min="1" max="9" step="1" id="scaleY" value="2">
										</td>
									</tr>
									<tr>
										<th>Image Rotation:</th>
										<td>
											<label for="rotateN"><input type="radio" name="rotate" value="N" id="rotateN" checked="">Normal</label>
											<label for="rotateR"><input type="radio" name="rotate" value="R" id="rotateR">Right</label>
											<label for="rotateL"><input type="radio" name="rotate" value="L" id="rotateL">Left</label>
											<label for="rotateI"><input type="radio" name="rotate" value="I" id="rotateI">Invert</label>
										</td>
									</tr>
									<tr>
										<th><label for="SVGRenderWithOnlyIntegers">Sharpen text:</label></th>
										<td><input type="checkbox" name="SVGRenderWithOnlyIntegers" id="SVGRenderWithOnlyIntegers"></td>
									</tr>
									<tr>
										<td></td>
										<td>
											<button style="margin-top:1ex" id="render" disabled>Show Barcode</button>
											<button style="margin-top:1ex" onclick="(()=>{gbID('logArea').textContent = '';})()">Clear Log</button> <br>
											<button style="margin-top:1ex" id="autoAAABarcodeColor" >Random AAA Barcode Color</button> <br>
											<button style="margin-top:1ex" id="autoComplementaryBarcodeColor" >Random Complementary Barcode Color</button>
										</td>
									</tr>
									<tr>
										<th>WCAG 2.0 Compliance:</th>
										<td class="borderify">
											<span>Luminance Ratio: 	<span id="LRatio">(uncalculated)</span></span><br />
											<table>
												<tbody>
													<tr>
														<td style="padding-right: 1em;">
															<span>AA Thin Text: 	<span class="passFail" id="AAThin"></span></span><br />
														</td>
														<td style="padding-right: 1em;">
															<span>AA Thick Text: 	<span class="passFail" id="AAThick"></span></span><br />
														</td>
														<td>
															<span>AA Input: 		<span class="passFail" id="AAInput"></span></span><br />
														</td>
													</tr>
													<tr>
														<td style="padding-right: 1em;">
															<span>AAA Thin Text: 	<span class="passFail" id="AAAThin"></span></span><br />
														</td>
														<td>
															<span>AAA Thick Text: 	<span class="passFail" id="AAAThick"></span></span><br />
														</td>
													</tr>
												</tbody>
											</table>
										</td>
									</tr>
									<tr>
										<th>Font Loader:</th>
										<td class="borderify">
											<form id="fontLoadForm">
												<span>File (.ttf & .otf only): <input type="file" id="fontfile" name="fontfile" accept=".otf,.ttf" required></span> <br><br>
												<span>Font Name: <input type="text" id="fontname" name="fontname" minlength="3" required></span> <br><br>
												<button type="submit">Load Font File</button>
											</form>
										</td>
									</tr>

									<tr>
										<th style="vertical-align: unset;">Log:</th>
										<td class="borderify"><div id='logArea'></div></td>
									</tr>
								</tbody>
							</table>
						</td>
					</tr>
				</tbody>
			</table>
		</div>
	</body>
	<style id="stylus-23" type="text/css" class="stylus">
		/** { outline: 1px solid blue; }*/

		#symtext, #symopts { min-height: 5em; width: 50vw; }
		#symbol, #symaltx { width: 100%; }
		
		/* bwip-js : lib/demo.css */
		body { font: 11pt "Lucida Grande",Calibri,Helvetica,Arial,sans-serif; margin: 0; }
		#header {
			background-color:	#212121;
			color:				#fff;
			height:				48px;
			padding: 1em 0 1em 1em;
		}
		#header #bwip-js  { font-size: 25px; font-weight: bold; }
		#header #versions { font-size: 12px; font-weight: 100; color: #a7a7a7; }
		#header > * { max-width: calc(100% - 2em); }
		input, select, label, button { font: 10.5pt Verdana, Arial, san-serif; }
		#symbol, #symtext, #symaltx, #symopts, #scaleX, #scaleY {
			padding:			.5ex;
			box-sizing:			border-box;
			border:				1px solid #999;
			border-radius:		4px;
		}
		#barcodeTypeOptions { min-width: 8em; }
		#params, #content { margin-left: 20px; margin-top: 10px; }
		#params > table { max-width: calc(100% - 20px); }
		#params th { text-align: right; padding-right: 1ex; max-width: 6em; }
		#params th > label { font-size: 11pt; font-weight: 700; font-family: "Lucida Grande",Calibri,Helvetica,Arial,sans-serif; }
		#mainparams td:not([colspan]) { max-width: 10em; }
		#textSize { max-width: 5em; }
		button { padding: .5ex 1ex; min-width: 18ex; }
		#LRatio { font-weight: bold; }
		span.passFail { font-weight: bold; }
		span.passFail::before { content: "(Uncalculated)"; }
		span.passFail[data-content='pass'] { color: darkgreen; }
		span.passFail[data-content='pass']::before { color: darkgreen; content: "Pass"; }
		span.passFail[data-content='fail'] { color: darkred; }
		span.passFail[data-content='fail']::before { color: darkred; content:"Fail"; }

		div#svgTarget { width: fit-content; }
		div#svgTarget[transparentbg='true'] {
			background:  repeating-conic-gradient(#808080 0% 25%, transparent 0% 50%) 50% / 20px 20px;
		}

		.borderify {
			padding: 0.5em; 
			border: 1px solid black;
		}


		#logArea {
			min-height: 		2em;
			max-height: 		10em;
			border: 			1px solid black;
			padding: 			0.3em;
			white-space:		pre-wrap;
			overflow-y: scroll;
			word-break: break-word;
			word-wrap: break-word;
		}

		#logArea span.loggederror {
			color: red;
			font-weight: bold;
		}
	</style>
</html>
