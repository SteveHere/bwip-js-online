<!DOCTYPE html>
<!-- saved from url=(0044)https://bwip-js.metafloor.com/demo/demo.html -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>SteveHere's bwip-js Barcode Generator fork</title>
		<meta name="keywords" content="bar code, barcode generator, online barcode generator, free barcode generator, javascript, javascript library, nodejs, QR Code, EAN, EAN 13, Code 128, UPC, ISBN, ITF 14, Code 39, GS1, GS1 128, PDF417, HIBC, DataMatrix, Data Matrix, DataBar, OCR, OCR B, OCR font, Aztec Code, PostNet, USPS, Pharmacode">
		<meta name="description" content="JavaScript barcode generator and library.  Create any barcode in your browser.">

		<link rel="icon" type="image/x-icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAWCAYAAAChWZ5EAAAAAXNSR0IArs4c6QAAAHBJREFUSEtjZBhgwDjA9jMMKgf8p3NogD2PHAKDwwH//9PWHYyMcD9jDwGQA0CKiKVBwUisWpg6aFSPOmA0BEZDYAiEAK6iGVZOIMtjE8MmT1JBNGAOoGWlRDAEaGk5mtmDrzako+cRVg2qFtGAhAAA5KxUJnw2rHsAAAAASUVORK5CYII=">

		<link rel="preload" href="./bwip-js_files/bwip-js-min.js" as="script" />
		<link rel="preload" href="./bwip-js_files/fonts.js" as="script" />
		<link rel="preload" href="./bwip-js_files/drawing-svg.js" as="script" />
		<link rel="preload" href="./bwip-js_files/barcodeTypeOptions.js" as="script" />

		<script type="text/javascript" src="./bwip-js_files/bwip-js-min.js"></script>
		<script type="text/javascript">
			// file: bwip-js/lib/symdesc.js
			//
			// This code was automatically generated from:
			// Barcode Writer in Pure PostScript - Version 2021-02-06
			//
			// Copyright (c) 2011-2021 Mark Warren
			// Copyright (c) 2004-2021 Terry Burton
			//
			// Licensed MIT.  See the LICENSE file in the bwip-js root directory
			// for the extended copyright notice.
			var symdesc = {
				"ean5":								"EAN-5 (5 digit addon)",
				"ean2":								"EAN-2 (2 digit addon)",
				"ean13":							"EAN-13",
				"ean8":								"EAN-8",
				"upca":								"UPC-A",
				"upce":								"UPC-E",
				"isbn":								"ISBN",
				"ismn":								"ISMN",
				"issn":								"ISSN",
				"code128":							"Code 128",
				"gs1-128":							"GS1-128",
				"ean14":							"GS1-14",
				"sscc18":							"SSCC-18",
				"code39":							"Code 39",
				"code39ext":						"Code 39 Extended",
				"code32":							"Italian Pharmacode",
				"pzn":								"Pharmazentralnummer (PZN)",
				"code93":							"Code 93",
				"code93ext":						"Code 93 Extended",
				"interleaved2of5":					"Interleaved 2 of 5 (ITF)",
				"itf14":							"ITF-14",
				"identcode":						"Deutsche Post Identcode",
				"leitcode":							"Deutsche Post Leitcode",
				"databaromni":						"GS1 DataBar Omnidirectional",
				"databarstacked":					"GS1 DataBar Stacked",
				"databarstackedomni":				"GS1 DataBar Stacked Omnidirectional",
				"databartruncated":					"GS1 DataBar Truncated",
				"databarlimited":					"GS1 DataBar Limited",
				"databarexpanded":					"GS1 DataBar Expanded",
				"databarexpandedstacked":			"GS1 DataBar Expanded Stacked",
				"gs1northamericancoupon":			"GS1 North American Coupon",
				"pharmacode":						"Pharmaceutical Binary Code",
				"pharmacode2":						"Two-track Pharmacode",
				"code2of5":							"Code 25",
				"industrial2of5":					"Industrial 2 of 5",
				"iata2of5":							"IATA 2 of 5",
				"matrix2of5":						"Matrix 2 of 5",
				"coop2of5":							"COOP 2 of 5",
				"datalogic2of5":					"Datalogic 2 of 5",
				"code11":							"Code 11",
				"bc412":							"BC412",
				"rationalizedCodabar":				"Codabar",
				"onecode":							"USPS Intelligent Mail",
				"postnet":							"USPS POSTNET",
				"planet":							"USPS PLANET",
				"royalmail":						"Royal Mail 4 State Customer Code",
				"auspost":							"AusPost 4 State Customer Code",
				"kix":								"Royal Dutch TPG Post KIX",
				"japanpost":						"Japan Post 4 State Customer Code",
				"msi":								"MSI Modified Plessey",
				"plessey":							"Plessey UK",
				"telepen":							"Telepen",
				"telepennumeric":					"Telepen Numeric",
				"posicode":							"PosiCode",
				"codablockf":						"Codablock F",
				"code16k":							"Code 16K",
				"code49":							"Code 49",
				"channelcode":						"Channel Code",
				"flattermarken":					"Flattermarken",
				"raw":								"Custom 1D symbology",
				"daft":								"Custom 4 state symbology",
				"symbol":							"Miscellaneous symbols",
				"pdf417":							"PDF417",
				"pdf417compact":					"Compact PDF417",
				"micropdf417":						"MicroPDF417",
				"datamatrix":						"Data Matrix",
				"datamatrixrectangular":			"Data Matrix Rectangular",
				"datamatrixrectangularextension":	"Data Matrix Rectangular Extension",
				"mailmark":							"Royal Mail Mailmark",
				"qrcode":							"QR Code",
				"swissqrcode":						"Swiss QR Code",
				"microqrcode":						"Micro QR Code",
				"rectangularmicroqrcode":			"Rectangular Micro QR Code",
				"maxicode":							"MaxiCode",
				"azteccode":						"Aztec Code",
				"azteccodecompact":					"Compact Aztec Code",
				"aztecrune":						"Aztec Runes",
				"codeone":							"Code One",
				"hanxin":							"Han Xin Code",
				"dotcode":							"DotCode",
				"ultracode":						"Ultracode",
				"gs1-cc":							"GS1 Composite 2D Component",
				"ean13composite":					"EAN-13 Composite",
				"ean8composite":					"EAN-8 Composite",
				"upcacomposite":					"UPC-A Composite",
				"upcecomposite":					"UPC-E Composite",
				"databaromnicomposite":				"GS1 DataBar Omnidirectional Composite",
				"databarstackedcomposite":			"GS1 DataBar Stacked Composite",
				"databarstackedomnicomposite":		"GS1 DataBar Stacked Omnidirectional Composite",
				"databartruncatedcomposite":		"GS1 DataBar Truncated Composite",
				"databarlimitedcomposite":			"GS1 DataBar Limited Composite",
				"databarexpandedcomposite":			"GS1 DataBar Expanded Composite",
				"databarexpandedstackedcomposite":	"GS1 DataBar Expanded Stacked Composite",
				"gs1-128composite":					"GS1-128 Composite",
				"gs1datamatrix":					"GS1 Data Matrix",
				"gs1datamatrixrectangular":			"GS1 Data Matrix Rectangular",
				"gs1qrcode":						"GS1 QR Code",
				"gs1dotcode":						"GS1 DotCode",
				"hibccode39":						"HIBC Code 39",
				"hibccode128":						"HIBC Code 128",
				"hibcdatamatrix":					"HIBC Data Matrix",
				"hibcdatamatrixrectangular":		"HIBC Data Matrix Rectangular",
				"hibcpdf417":						"HIBC PDF417",
				"hibcmicropdf417":					"HIBC MicroPDF417",
				"hibcqrcode":						"HIBC QR Code",
				"hibccodablockf":					"HIBC Codablock F",
				"hibcazteccode":					"HIBC Aztec Code"
			};
		</script>
		<script type="module" src="./bwip-js_files/fonts.js"></script>
		<script type="text/javascript" src="./bwip-js_files/drawing-svg.js"></script>
		<script type="text/javascript" src="./bwip-js_files/barcodeTypeOptions.js"></script>
		<script type="module">
			import fontList from './bwip-js_files/fonts.js';
			window.fontLoaderLoop = setInterval(()=>{
				let start = performance.now();

				let fontOptions = document.getElementById('barcodeTextFontType');
				for (const [fontName, fontFullName, fontData] of fontList) {
					window.bwipjs.loadFont(fontName, fontData);
					fontOptions.append(new Option(fontFullName, fontName));
				}
				
				window.writeToLog(`Fonts loaded in ${(performance.now() - start).toFixed(3)}ms`);
				document.getElementById('render').disabled = false;
				window.fontLoadComplete = true;

				clearInterval(window.fontLoaderLoop);
				window.writeToLog("cleared font loader");
			}, 100);
		</script>
		<script type="text/javascript">
			const gbID =(x)=>document.getElementById(x);
			let triggerDownload = (imgURI, fileName) => {
				(a=>{a.click()})(Object.assign(document.createElement('a'), { 'download': fileName, 'href': imgURI }))
			}

			const getsRGB = c => (x=>((x <= 0.03928) ? x / 12.92 : Math.pow(((x + 0.055) / 1.055), 2.4)))(parseInt(c, 16) / 255);
			const getL = c => (0.2126 * getsRGB(c[0]+c[1]) + 0.7152 * getsRGB(c[2]+c[3]) + 0.0722 * getsRGB(c[4]+c[5]));
			const getLRatio = (fg, bg) => ((fgl, bgl)=>(Math.max(fgl, bgl) + 0.05) / (Math.min(fgl, bgl) + 0.05))(getL(fg), getL(bg));
			const hti=(hex)=>parseInt(hex, 16);
			const hexToRGB=(hex = "#000000")=>[hti(hex[1] + hex[2]), hti(hex[3] + hex[4]), hti(hex[5] + hex[6])];

			// Adapted & optimized from https://gist.github.com/mjackson/5311256
			function RGBtoHSL(r = 0, g = 0, b = 0){ r /= 255, g /= 255, b /= 255;
				let max=Math.max(r,g,b), min=Math.min(r,g,b); let d=max-min, l2=max+min; // l2 = lightness * 2 

				if (max == min) return { h: 0, s: 0, l: l2/2 }; // h = [0-1], s = [0-1], l = [0-1]
				return {h:{[r]:(g-b)/d+(g<b?6:0), [g]:(b-r)/d+2, [b]:(r-g)/d+4}[max]/6, s:d/(l2>1?(2-l2):l2), l:l2/2 } 
			}

			function hue2rgb(p, q, t) {
				t = (t < 0) ? t + 1 : ((t > 1) ? t - 1 : t );
				if (t < 1/6) return p + (q - p) * 6 * t;
				if (t < 1/2) return q;
				if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
				return p;
			}

			function hslToRgb(h = 0, s = 0, l = 0) { // h = [0-1], s = [0-1], l = [0-1]
				// r = [0-255], g = [0-255], b = [0-255]
				if (s == 0) return [ (l * 255)|0, (l * 255)|0, (l * 255)|0 ]; 

				const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				const p = 2 * l - q;
				return [ 
					(hue2rgb(p, q, h + 1/3) * 255)|0,  (hue2rgb(p, q, h) * 255)|0,  (hue2rgb(p, q, h - 1/3) * 255)|0
				];
			}


			function saveCanvas(type, ext) {
				let barcodeSVG = gbID('svgTarget').firstElementChild.cloneNode(true);
	            // if(id("transparent").checked) avatar.getElementById("background-color").style.opacity = 0;

	            let svgBlob = new Blob([(new XMLSerializer()).serializeToString(barcodeSVG)], {type: 'image/svg+xml;charset=utf-8'});
	  			let img = new Image();
	            img.onload = ()=>{ 
	            	let canvas = document.createElement("canvas");
	                canvas.width=barcodeSVG.width.baseVal.value; canvas.height=barcodeSVG.height.baseVal.value;
	                let ctx = canvas.getContext("2d"); ctx.drawImage(img, 0, 0);
	                triggerDownload(canvas.toDataURL(type), saveCanvas.basename + ext);
	            };
	            img.setAttribute("src", URL.createObjectURL(svgBlob));
			}
			
			function saveSVG() {
				triggerDownload(URL.createObjectURL(new Blob([gbID('svgTarget').innerHTML], {type: "image/svg+xml"})), `${saveCanvas.basename}.svg`);
			}
			

			function setURL(opts) {
				let args = [];
				for (const [key, value] of Object.entries(opts)) {
					if (key === 'bcid') continue;
					if (['includecheck', 'includetext', 'includecheckintext'].includes(key)){
						if(value){ args.push(key); }
					} else {
						args.push(`${key}=${['text', 'alttext'].includes(key) ? encodeURIComponent(value) : value}`);
					}
				}
				gbID('apiurl').href = `./make_barcode/?bcid=${opts['bcid']}&${args.join('&')}`;
			}

			window.writeToLog = (text, error=false)=>{
				let log = gbID('logArea')
				log.append(
					Object.assign(document.createElement('span'), {
						textContent: `${(new Date()).toLocaleTimeString('en-US', { hour12: false })} - ${text}`,
						...(error && { 'className': 'loggederror' }),
					}),
					document.createElement('br')
				)
				log.scrollTo(0, log.scrollHeight);
			};

			function render() {
				let settings = {
					symbol: gbID('symbol').value,
					version: gbID('barcodeTypeOptions').value,
					text: gbID('symtext').value.trim(),
					alttext: gbID('symaltx').value.trim(),
					rotate: document.querySelector('input[name="rotate"]:checked').value,
					scaleX: +gbID('scaleX').value || 2,
					scaleY: +gbID('scaleY').value || 2,
					textScaleWidth: +gbID('textScaleWidth').value || 1,
					textScaleHeight: +gbID('textScaleHeight').value || 1,
					textOffsetX: +gbID('textOffsetX').value || 0,
					textOffsetY: +gbID('textOffsetY').value || 0,
					fontType: gbID('barcodeTextFontType').value,
					fontSize: gbID('textSize').value,
					includeCheck: gbID('includeCheck').checked,
					includeText: gbID('includeText').checked,
					includeCheckInText: gbID('includeCheckInText').checked,
					miscOptions: gbID('symopts').value.trim(),
					SVGRenderWithOnlyIntegers: gbID('SVGRenderWithOnlyIntegers').checked,
					fgColor: gbID('fgcolor').value.substr(1),
					bgColor: gbID('bgcolor').value.substr(1),
					transparentBG: gbID('transparentBG').checked,
					padding: gbID('padding').value || 0,
					forceOldRender: gbID('forceOldRender').checked || false,
					parseAsUTF8: gbID('parseAsUTF8').checked??true,
				}

				localStorage.setItem('bwipjsLastSettings', JSON.stringify(settings));

				// Clear the page
				gbID('saveas').style.visibility = 'hidden';
				gbID('svgTarget').innerHTML = '';
				gbID('svgTarget').setAttribute('transparentBG', settings.transparentBG);

				// These opts already exist & will always be present (unless the DOM's been tampered)
				let mandated_flags = {
					'text': (settings.parseAsUTF8 ? '^ECI000026' : '') + settings.text,
					'alttext': settings.alttext,
					'bcid': settings.symbol,
					'scaleX': settings.scaleX,
					'scaleY': settings.scaleY,
					'rotate': settings.rotate,
					'textfont': settings.fontType,
					'textsize': settings.fontSize,
					'barcolor': settings.fgColor,
					'textcolor': settings.fgColor,
					'padding': settings.padding,

					...((settings.version !== "(auto)") && {'version': settings.version}),
					...((document.querySelector('#barcodeTypeOptions option:checked').parentElement.label !== undefined) && {
						'format': document.querySelector('#barcodeTypeOptions option:checked').parentElement.label.split(": ")[1]
					}),
					...(!settings.transparentBG && {'backgroundcolor': settings.bgColor}),
					...(settings.includeCheck && {'includecheck': settings.includeCheck}),
					...(settings.includeText && {'includetext': settings.includeText}),
					...(settings.includeCheckInText && {'includecheckintext': settings.includeCheckInText}),
					...(settings.parseAsUTF8 && {'parsefnc': settings.parseAsUTF8}),
				}

				// Convert the misc options to an object.
				let miscOpts = {};
				for (const opt of settings.miscOptions.split(/\s+/)) {
					const parts = opt.split('=');
					if (opt.length === 0 || parts[0].length === 0) continue;
					if (parts[0] === 'backgroundcolor') continue;
					if (parts[0] === 'includecheck') continue;
					if (parts[0] === 'includetext') continue;
					if (parts[0] === 'includecheckintext') continue;
					if (parts[0] === 'parsefnc') continue;

					if (parts.length == 1) {
						miscOpts[parts[0]] = true;
					} else {
						miscOpts[parts[0]] = parts[1];
					}
				}

				const opts = {...miscOpts, ...mandated_flags};
				// console.log(miscOpts, mandated_flags);

				// Draw the bar code to the canvas
				let display = false;
				try {
					const ts0 = performance.now();
					let clonedOpts = Object.assign({}, opts);
					if (settings.forceOldRender) {
						const svgResult = bwipjs.toSVG(clonedOpts);
						let [ , width, height ] = /viewBox="0 0 (\d+) (\d+)"/.exec(svgResult);
						gbID('svgTarget').innerHTML = svgResult;
						gbID('svgTarget').firstElementChild.setAttribute('width', width);
						gbID('svgTarget').firstElementChild.setAttribute('height', height);
					} else {
						const svgResult = bwipjs.render(
							clonedOpts, 
							window.DrawingSVG(
								clonedOpts, window.bwipjs.FontLib, settings.SVGRenderWithOnlyIntegers,
								textScale={width: settings.textScaleWidth, height: settings.textScaleHeight},
								textOffset={x: settings.textOffsetX, y: settings.textOffsetY}
							)
						);
						gbID('svgTarget').innerHTML = svgResult;
					}

					const LRatio = getLRatio(settings.fgColor, settings.bgColor);
					gbID('LRatio').textContent = LRatio.toFixed(3);

					gbID('AAThin').setAttribute('data-content', (LRatio >= 4.5) ? "pass" : "fail");
					gbID('AAThick').setAttribute('data-content', (LRatio >= 3) ? "pass" : "fail");
					gbID('AAAThin').setAttribute('data-content', (LRatio >= 7) ? "pass" : "fail");
					gbID('AAAThick').setAttribute('data-content', (LRatio >= 4.5) ? "pass" : "fail");
					gbID('AAInput').setAttribute('data-content', (LRatio >= 3) ? "pass" : "fail");

					show(ts0, performance.now(), opts);
					display = true;
				} catch (e) {
					// Watch for BWIPP generated raiseerror's.
					let msg = ('' + e).trim();
					if (msg.indexOf("bwipp.") >= 0) {
						window.writeToLog(msg, true);
					} else if (e.stack) {
						// GC includes the message in the stack.  FF does not.
						window.writeToLog((e.stack.indexOf(msg) == -1 ? msg + '\n' : '') + e.stack, true);
					} else {
						window.writeToLog(msg, true);
					}
					throw e;
				}

				gbID('resultsContainer').classList.toggle('hide', !display);

				function show(ts0, ts1, opts) {
					setURL(opts);
					window.writeToLog(`Barcode rendered in ${(ts1 - ts0).toFixed(3)} msecs`);
					gbID('saveas').style.visibility = 'visible';
					saveCanvas.basename = opts.bcid + '-' + opts.text.split("\n")[0].replace(/[^a-zA-Z0-9._]+/g, '-');
				}
			}
			
			window.addEventListener('load', function() { 
				// Set up the select list of barcode types
				{
					let opts = Object.entries(symdesc);
					opts.sort(function(a, b) { return a[1] < b[1] ? -1 : 1 });
					gbID('symbol').append(...opts.map(opt=>new Option(opt[1], opt[0])));
				}
				
				gbID('symbol').addEventListener('change', function(ev) {
					gbID('saveas').style.visibility = 'hidden';
					console.log(ev.target.value)
					window.changeBarcodeOptions(gbID('barcodeTypeOptions'), ev.target.value);
					render();
				});

				function dTh(val){ return (val).toString(16).padStart(2, '0'); }
				
				gbID('scaleX').addEventListener('change', function(ev) { gbID('scaleY').value = ev.target.value; });
				gbID('render').addEventListener('click', render);
				gbID('autoAAABarcodeColor').addEventListener('click', function(ev) {
					ev.target.disabled = true;

					setTimeout(()=>{
						let ts0 = performance.now();

						// Goal: Calculate color with min L ratio of 7
						let bgC = gbID('bgcolor').value.substr(1);
						let bgL = getL(bgC);
						const min_L_ratio = 5, AAA_ratio = 7;

						let fgCElement = gbID('fgcolor');
						let possible_rgbs = [];
						const step = 4;

						// Brute force is the easiest understandable solution towards finding the fg color
						// Number of iterations: (int(255/step))^3
						// At step = 4, search space is computable in ~300ms. 
						for (let r = 0; r <= 255; r += step){
							for (let g = 0; g <= 255; g += step){
								for (let b = 0; b <= 255; b += step){
									const fgC = `${dTh(r)}${dTh(g)}${dTh(b)}`;
									const fgL = getL(fgC);
									const LRatio = (Math.max(fgL, bgL) + 0.05) / (Math.min(fgL, bgL) + 0.05);
									if (LRatio >= min_L_ratio) {
										possible_rgbs.push([fgC, LRatio]);
									}
								}
							}
						}

						if (possible_rgbs.some(e=>e[1] >= AAA_ratio)){
							writeToLog("Using guessed AAA-compliant color that achieves minimum luminance contrast ratio");
							let AAA = possible_rgbs.filter(e=>e[1] >= AAA_ratio);
							fgCElement.value = `#${AAA[(Math.random()*AAA.length)|0][0]}`;
						} else if (possible_rgbs.some(e=>e[1] >= 6)){
							writeToLog("Unable to find AAA-compliant color - Using colors with minimum LCR >= 6");
							let al6 = possible_rgbs.filter(e=>e[1] >= 6);
							fgCElement.value = `#${al6[(Math.random()*al6.length)|0][0]}`;
						} else if (possible_rgbs.length > 0) {
							writeToLog("Unable to find AAA-compliant color - Using colors with minimum LCR >= 5");
							fgCElement.value = `#${possible_rgbs[(Math.random()*possible_rgbs.length)|0][0]}`;
						} else {
							writeToLog("Unable to find AAA-compliant color - Defaulting to black/white");
							fgCElement.value = `#${getLRatio('000000', bgC) > getLRatio('FFFFFF', bgC) ? '000000' : 'FFFFFF'}`;
						}

						writeToLog(`Computed fg color guess in ${ (performance.now() - ts0).toFixed(3) } ms`);
						ev.target.disabled = false;

						render();
					}, 0);
				});

				gbID('autoComplementaryBarcodeColor').addEventListener('click', function(ev) {
					ev.target.disabled = true;

					setTimeout(()=>{
						let ts0 = performance.now();

						// Goal: Calculate barcode & text (foreground) color with min L ratio of 7
						let bgRGBHex = gbID('bgcolor').value.substr(1);
						let bgRGB = hexToRGB(gbID('bgcolor').value);
						let bgHSL = RGBtoHSL(bgRGB[0], bgRGB[1], bgRGB[2]);
						let fgH = (bgHSL.h + 0.5) % 1;

						const min_L_ratio = 5;

						let fgCElement = gbID('fgcolor');

						let LValues = [];
						for(let fgl = 0; fgl <= 100; fgl++){
							const fgRGBHex = (x=>`${dTh(x[0])}${dTh(x[1])}${dTh(x[2])}`)(hslToRgb(fgH, bgHSL.s, Math.min(1, fgl * 0.01)));
							const lratio = getLRatio(fgRGBHex, bgRGBHex);
							if(lratio > 4){ LValues.push([fgRGBHex, lratio]); }
						}
						
						if (LValues.some(v=>v[1] >= min_L_ratio)) {
							let LValuesT = LValues.filter(v=>v[1] >= min_L_ratio);
							fgCElement.value = `#${LValuesT[(Math.random()*LValuesT.length)|0][0]}`;
						} else {
							// LCR = (Math.max(fgl, bgl) + 0.05) / (Math.min(fgl, bgl) + 0.05)
							// fgl & bgl range := [0, 1]
							// fgl > bgl |=> LCR = (fgl + 0.05) / (bgl + 0.05)
							// 			 |=> LCR * bgl + (LCR - 1) * 0.05 = fgl 
							//			 | To satisfy fgl > bgl requirement, where fgl = 1:
							//           | 1 > LCR * bgl + (LCR - 1) * 0.05
							//			 |=> ( ( 1.05 - 0.05 * LCR ) / LCR > bgl)
							//
							// bgl > fgl |=> LCR = (bgl + 0.05) / (fgl + 0.05)
							// 			 |=> LCR * fgl + (LCR - 1) * 0.05 = bgl
							//			 |=> fgl = (bgl - ((LCR - 1) * 0.05)) / LCR
							//           | To satisfy bgl > fgl requirement, where fgl = 1:
							//           | (bgl - ((LCR - 1) * 0.05)) / LCR > 1
							//			 |=> ( bgl > ((LCR - 1) * 0.05) )
							//
							// (LCR = X) |=> ( 1.05 - 0.05 * X ) / X = ((X - 1) * 0.05)
							// 			 |=> 1.05 - 0.05 * X = 0.05*X*X - 0.05*X
							//			 |=> sqrt(1.05/0.05) = X ~ 4.58257569495584
							writeToLog(`Unable to find HSL with LCR >= 5: Finding min HSL with LCR >= 4.58`);
							let LValuesT = LValues.filter(v=>v[1] >= 4.58);
							fgCElement.value = `#${LValuesT[(Math.random()*LValuesT.length)|0][0]}`;
						}

						writeToLog(`Computed complementary fg color in ${ (performance.now() - ts0).toFixed(3) } ms`);
						ev.target.disabled = false;

						render();
					}, 0);
				});

				gbID('fontLoadForm').addEventListener('submit', async function (ev) {
					ev.preventDefault();
					try {
						const fontname = gbID('fontname').value;
						if ([...gbID('barcodeTextFontType').options].some(e=>e.textContent.toUpperCase()===fontname.toUpperCase() || e.value.toUpperCase()===fontname.toUpperCase())){
							writeToLog("Cannot load font - font name has already been used.", true);
						} else {
							const buffer = await gbID('fontfile').files[0].arrayBuffer();
							window.bwipjs.loadFont(fontname, buffer);

							gbID('barcodeTextFontType').append(new Option(fontname, fontname));
							writeToLog(`Font '${fontname}' loaded.`);
						}
					} catch (e) {
						// Watch for BWIPP generated raiseerror's.
						let msg = ('' + e).trim();
						if (e.stack) {
							// GC includes the message in the stack.  FF does not.
							window.writeToLog((e.stack.indexOf(msg) == -1 ? msg + '\n' : '') + e.stack, true);
						} else {
							window.writeToLog(msg, true);
						}
					}
				});
				gbID('saveas').style.visibility = 'hidden';

				// Allow Enter to render
				gbID('params').addEventListener('keypress', function(ev) { if (ev.which == 13) { render(); ev.stopPropagation(); ev.preventDefault(); return false; } });

				gbID('versions').textContent = 'bwip-js ' + bwipjs.BWIPJS_VERSION + ' / BWIPP ' + bwipjs.BWIPP_VERSION;

				document.addEventListener('change', function(ev){ 
					if(!['symtext', 'symaltx', 'symbol'].includes(ev.target.id)){
						render(); 
					}
				});
				gbID('symtext').addEventListener('input', function (ev) { 
					if(ev.target.value.length === 0){ ev.target.value = "12345"; }
					render(); ev.stopPropagation(); ev.preventDefault(); return false; 
				});
				gbID('symaltx').addEventListener('input', function (ev) { render(); ev.stopPropagation(); ev.preventDefault(); return false; });
				gbID('textOffsetReset').addEventListener('click', function (ev) { 
					gbID('textOffsetX').value = 0;
					gbID('textOffsetY').value = 0;
					render();
				});
				gbID('fixTextAlignment').addEventListener('click', function (ev) { 
					const svg = gbID('svgTarget').children[0];
					const linesArea = svg.querySelectorAll('g#linesArea')[0];
					const notTextAreas = svg.querySelectorAll('path.not-text');
					const text = svg.querySelectorAll('g.text')[0];
					const getVal = (x, y) => x.getBoundingClientRect()[y];
					console.log("fta", gbID('textOffsetX').valueAsNumber, text.getBoundingClientRect(), svg.getBoundingClientRect());

					let newTextOffsetX = 0, newTextOffsetY = 0;
					const rotation = document.querySelector('input[name="rotate"]:checked').value;

					if (rotation == "N") {
						if (gbID('textScaleWidth').valueAsNumber === 1) {
							newTextOffsetX = 0;
						} else if (gbID('textOffsetX').valueAsNumber === 0) {
							newTextOffsetX = -(getVal(text, 'x') - getVal(svg, 'x') - (getVal(svg, 'width') - getVal(text, 'width'))/2 )|0
						} else {
							const ideal = (getVal(svg, 'width') - getVal(text, 'width'))/2;
							const current = getVal(text, 'x') - getVal(svg, 'x');
							newTextOffsetX = (gbID('textOffsetX').valueAsNumber + (ideal - current))|0;
						}

						if (gbID('textScaleHeight').valueAsNumber === 1) {
							newTextOffsetY = 0;
						} else if (gbID('textOffsetY').valueAsNumber === 0) {
							newTextOffsetY = (-(
								getVal(svg, 'height') 
								- [...notTextAreas].map(e=>getVal(e, 'height')).reduce((acc, val)=>acc + val, 0) 
								- getVal(text, 'height')
								- ((+gbID('scaleY').value || 2) * (gbID('padding').value || 0) * 3)
							))|0;
						} else {
							const ideal = (getVal(svg, 'height') - getVal(text, 'height'))/2;
							const current = getVal(text, 'y') - getVal(svg, 'y');
							newTextOffsetY = (gbID('textOffsetX').valueAsNumber + (ideal - current))|0;
						}
					}

					gbID('textOffsetX').value = newTextOffsetX;
					gbID('textOffsetY').value = newTextOffsetY;
					render();
				});
				gbID('manual-flexify').addEventListener('click', function (ev) { 
					window.toggleFlexCSS = !window.toggleFlexCSS;
					if (window.toggleFlexCSS) {
						document.body.classList.remove('ignore-flexify');
					} else {
						document.body.classList.add('ignore-flexify');
					}
				});
				gbID('manual-flexify').addEventListener('click', (ev)=>{ gbID('logArea').textContent = ''; });

				window.savedDataLoader = setInterval(function() {
					if(window.fontLoadComplete === true){
						let element = gbID("symtext");

					    function pasteIntoInput(el, text) {
					        el.focus();
					        if (typeof el.selectionStart == "number" && typeof el.selectionEnd == "number") {
					            let val = el.value, selStart = el.selectionStart;
					            el.value = val.slice(0, selStart) + text + val.slice(el.selectionEnd);
					            el.selectionEnd = el.selectionStart = selStart + text.length;
					        } else if (typeof document.selection != "undefined") {
					            let textRange = document.selection.createRange();
					            textRange.text = text;
					            textRange.collapse(false);
					            textRange.select();
					        }
					    }

					    function handleEnter(evt) {
					        let insert = ({13: '\n', 9: '\t'})[evt.keyCode];
					        if (insert !== undefined){ pasteIntoInput(evt.target, insert); evt.preventDefault(); }
					    }
					    element = gbID("symtext");
					    // Handle both keydown and keypress for Opera, which only allows default
					    // key action to be suppressed in keypress
					    element.addEventListener('keydown', handleEnter);
					    element.addEventListener('keypress', handleEnter);

						var saved;
						try { saved = JSON.parse(localStorage.getItem('bwipjsLastSettings')); } catch (e) { console.error(e); }

					    if (saved) {
							if (saved.symbol) { gbID('symbol').value = saved.symbol; } else { gbID('symbol').value = "qrcode"; }
							window.changeBarcodeOptions(gbID('barcodeTypeOptions'),  gbID('symbol').value);
							if (saved.version) { gbID('barcodeTypeOptions').value = saved.version; }
							if (saved.text) { gbID('symtext').value = saved.text; }
							if (saved.alttext) { gbID('symaltx').value = saved.alttext; }
							if (saved.scaleX && saved.scaleY) { 
								gbID('scaleX').value = saved.scaleX; 
								gbID('scaleY').value = saved.scaleY; 
							}
							if (saved.textScaleWidth && saved.textScaleHeight) {
								gbID('textScaleWidth').value = saved.textScaleWidth;
								gbID('textScaleHeight').value = saved.textScaleHeight;
							}
							if (saved.rotate) { gbID('rotate' + saved.rotate).checked = true; }
							if (saved.fontType) { 
								if([...gbID('barcodeTextFontType').options].some(e=>e.value === saved.fontType)){
									gbID('barcodeTextFontType').value = saved.fontType; 
								} else {
									gbID('barcodeTextFontType').value = "OCR-A";
								}
							}
							if (saved.fontSize) { gbID('textSize').value = saved.fontSize; }
							if (saved.includeCheck) { gbID('includeCheck').checked = saved.includeCheck; }
							if (saved.includeText) { gbID('includeText').checked = saved.includeText; }
							if (saved.includeCheckInText) { gbID('includeCheckInText').checked = saved.includeCheckInText; }
							if (saved.miscOptions) { gbID('symopts').value = saved.miscOptions; }
							if (saved.SVGRenderWithOnlyIntegers) { gbID('SVGRenderWithOnlyIntegers').checked = saved.SVGRenderWithOnlyIntegers; }
							if (saved.padding) { gbID('padding').value = saved.padding; }

							if (saved.fgColor) { gbID('fgcolor').value = `#${saved.fgColor}`; }
							if (saved.bgColor) { gbID('bgcolor').value = `#${saved.bgColor}`; }
							if (saved.transparentBG) {  gbID('transparentBG').checked = saved.transparentBG; }
							if (saved.forceOldRender) { gbID('forceOldRender').checked = saved.forceOldRender; }
							if (saved.parseAsUTF8) { gbID('parseAsUTF8').checked = saved.parseAsUTF8; }
						} else {
							gbID('symbol').value = "qrcode";
							window.changeBarcodeOptions(gbID('barcodeTypeOptions'),  gbID('symbol').value);
						}

					    try {
					    	if(saved){ render(); }
							else { gbID('symtext').value = "example"; render(); }
					    } catch (e) {
					    	writeToLog("Unable to render saved barcode params", true);
					    	console.error(e);
					    }
					    clearInterval(window.savedDataLoader);
					    writeToLog("Cleared saved data loader loop");
					} else { writeToLog("Fonts not loaded in yet - Relooping"); }
				}, 200);
			});

			
		</script>
	</head>

	<body class="ignore-flexify">
		<div id="header"> 
			<div id="bwip-js">bwip-js // Barcode Writer in Pure JavaScript <a href="https://github.com/SteveHere/bwip-js-online" target="_blank">(SteveHere's fork)</a></div> 
			<div id="versions"></div>
			<button id="manual-flexify">Toggle Flex CSS</button>
		</div>

		<div id="main-area">
			<div id="barcode-area">
				<div class="flexify perma-flex">
					<span>Barcode Type:</span>
					<div><select id="symbol"></select></div>
					<span>Version:</span>
					<div><select id="barcodeTypeOptions"></select></div>
				</div>
				<div>
					<span>Bar Text:</span>
					<div><textarea id="symtext" type="text"></textarea></div>
				</div>
				<div>
					<span>Alt Text:</span>
					<div><input id="symaltx" type="text"></div>
				</div>

				<div id="resultsContainer" class="hide">
					<span>Result: </span>
					<div id="content">
						<div id="svgTarget"></div>
					</div>
					
					<div>
						<div id="saveas" style="visibility: hidden;">
							<a class="saveas" href="javascript:saveSVG()">Save As SVG</a>
							&nbsp;&nbsp;
							<a class="saveas" href="javascript:saveCanvas('image/png','.png')">Save As PNG</a>
							&nbsp;&nbsp;
							<a class="saveas" href="javascript:saveCanvas('image/jpeg','.jpg')">Save As JPEG</a>
							&nbsp;&nbsp;
							<a class="saveas" id="apiurl" href="">Goto URL</a>
							&nbsp;&nbsp;
						</div>
					</div>
				</div>
			</div>

			<div id="params">
				<div class="optionContainer">
					<div class="flexify">
						<div class="flexify perma-flex">
							<span>Font Type:</span>
							<div><select id="barcodeTextFontType"></select></div>
						</div>
						<div class="flexify perma-flex pad-top">
							<span>Font Size:</span>
							<div><input id="textSize" type="number" value="10" min="1"></div>
							<span>Padding:</span>
							<div><input type="number" id="padding" value="1" min="0" step="1" max="10"></div>
						</div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span>Barcode & Text color:</span>
						<div><input type="color" id="fgcolor" value="#000000" /></div>
						<span>Background color:</span>
						<div><input type="color" id="bgcolor" value="#ffffff" /></div>
						<span><label for="transparentBG">Generate with transparent background:</label></span>
						<div><input type="checkbox" name="transparentBG" id="transparentBG" /></div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span><label for="includeText">Include text:</label></span>
						<div><input type="checkbox" name="includeText" id="includeText" /></div>
						<span><label for="includeCheck">Include check:</label></span>
						<div><input type="checkbox" name="includeCheck" id="includeCheck" /></div>
						<span><label for="includeCheckInText">Include check in text:</label></span>
						<div><input type="checkbox" name="includeCheckInText" id="includeCheckInText" /></div>
					</div>
				</div>
				<div class="optionContainer">
					<div class="flexify perma-flex pad-top">
						<span>Scale X,Y:</span>
						<div>
							<input type="number" min="1" max="9" step="1" id="scaleX" value="2">
							<input type="number" min="1" max="9" step="1" id="scaleY" value="2">
						</div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span>Text Scaling Width,Height:</span>
						<div>
							<input type="number" min="0.1" max="4" step="0.1" id="textScaleWidth" value="2">
							<input type="number" min="0.1" max="4" step="0.1" id="textScaleHeight" value="2">
						</div>
					</div>
					<div class="flexify perma-flex pad-top" style="flex-wrap: wrap;">
						<span>Text Offset X,Y:</span>
						<div>
							<input type="number" min="-200" max="200" step="1" id="textOffsetX" value="0">
							<input type="number" min="-200" max="200" step="1" id="textOffsetY" value="0">
						</div>
						<div class="pad-top">
							<button id="textOffsetReset">Clear Offsets</button>
							<button id="fixTextAlignment">Fix Text Alignment</button>
						</div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span>Image Rotation:</span>
						<div>
							<label for="rotateN"><input type="radio" name="rotate" value="N" id="rotateN" checked=""><span>Normal</span></label>
							<label for="rotateR"><input type="radio" name="rotate" value="R" id="rotateR"><span>Right</span></label>
							<label for="rotateL"><input type="radio" name="rotate" value="L" id="rotateL"><span>Left</span></label>
							<label for="rotateI"><input type="radio" name="rotate" value="I" id="rotateI"><span>Invert</span></label>
						</div>
					</div>
					
					<div class="flexify perma-flex pad-top">
						<span><label for="parseAsUTF8">Parse text as UTF-8:</label></span>
						<div><input type="checkbox" name="parseAsUTF8" id="parseAsUTF8" checked></div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span><label for="SVGRenderWithOnlyIntegers">Sharpen text:</label></span>
						<div><input type="checkbox" name="SVGRenderWithOnlyIntegers" id="SVGRenderWithOnlyIntegers"></div>
					</div>
					<div class="flexify perma-flex pad-top">
						<span><label for="forceOldRender">Use old renderer:</label></span>
						<div><input type="checkbox" name="forceOldRender" id="forceOldRender"></div>
					</div>
				</div>
				<div>
					<span>Other Options:</span>
					<div><textarea id="symopts" type="text"></textarea></div>
				</div>
				<div>
					<div></div>
					<div>
						<button style="margin-top:1ex" id="render" disabled>Show Barcode</button>
						<button style="margin-top:1ex" id="logClear">Clear Log</button> <br>
						<button style="margin-top:1ex" id="autoAAABarcodeColor" >Random AAA Barcode Color</button> <br>
						<button style="margin-top:1ex" id="autoComplementaryBarcodeColor" >Random Complementary Barcode Color</button>
					</div>
				</div>
				<div>
					<span>WCAG 2.0 Compliance:</span>
					<div class="borderify">
						<table>
							<tbody>
								<tr>
									<td><span>Luminance Ratio: 	<span id="LRatio">(uncalculated)</span></span></td>
								</tr>
								<tr>
									<td style="padding-right: 1em;">
										<span>AA Thin Text: 	<span class="passFail" id="AAThin"></span></span><br />
									</td>
									<td style="padding-right: 1em;">
										<span>AA Thick Text: 	<span class="passFail" id="AAThick"></span></span><br />
									</td>
									<td>
										<span>AA Input: 		<span class="passFail" id="AAInput"></span></span><br />
									</td>
								</tr>
								<tr>
									<td style="padding-right: 1em;">
										<span>AAA Thin Text: 	<span class="passFail" id="AAAThin"></span></span><br />
									</td>
									<td>
										<span>AAA Thick Text: 	<span class="passFail" id="AAAThick"></span></span><br />
									</td>
								</tr>
							</tbody>
						</table>
					</div>
				</div>
				<div>
					<span>Font Loader:</span>
					<div class="borderify">
						<form id="fontLoadForm">
							<span>File (.ttf & .otf only): <input type="file" id="fontfile" name="fontfile" accept=".otf,.ttf" required></span> <br><br>
							<span>Font Name: <input type="text" id="fontname" name="fontname" minlength="3" required></span> <br><br>
							<button type="submit">Load Font File</button>
						</form>
					</div>
				</div>

				<div>
					<span style="vertical-align: unset;">Log:</span>
					<div class="borderify"><div id='logArea'></div></div>
				</div>

			</div>
		</div>
	</body>
	<style id="stylus-23" type="text/css" class="stylus">
		/** { outline: 1px solid blue; }*/

		#symtext, #symopts { min-height: 5em; width: 100%; }
		#symbol, #symaltx, #barcodeTextFontType { width: 100%; }
		
		/* bwip-js : lib/demo.css */
		body { font: 1em "Lucida Grande",Calibri,Helvetica,Arial,sans-serif; margin: 0; }
		#header {
			background-color:	#212121;
			color:				#fff;
			padding: 1em 0 1em 1em;
		}
		#header #bwip-js  { font-size: 25px; font-weight: bold; }
		#header #versions { font-size: 12px; font-weight: 100; color: #a7a7a7; }
		#header > * { max-width: calc(100% - 2em); }
		input, select, label, button { font: Verdana, Arial, san-serif; }
		#symbol, #symtext, #symaltx, #symopts, #scaleX, #scaleY,
		#barcodeTypeOptions, #barcodeTextFontType, #textSize, #padding {
			padding:			.5ex;
			box-sizing:			border-box;
			border:				1px solid #999;
			border-radius:		4px;
		}
		#symtext, #symaltx, #symopts {
			margin-top: 0.2em;
		}
		#params, #barcode-area { padding: 0.5em 1.5em 5em 1.5em;}
		#content { padding: 1em;}
		/* #params > table { max-width: calc(100% - 20px); } */
		#params > div, #barcode-area > div { padding-top: 0.5em; }
		#params > div > span, #barcode-area > div > span { font-weight: bold; }
		#params div > label, #barcode-area div > label { font-weight: 700; font-family: "Lucida Grande",Calibri,Helvetica,Arial,sans-serif; }
		#mainparams td:not([colspan]) { max-width: 10em; }
		#textSize { max-width: 5em; }
		button { padding: .5ex 1ex; min-width: 18ex; }
		#LRatio { font-weight: bold; }
		span.passFail { font-weight: bold; }
		span.passFail::before { content: "(Uncalculated)"; }
		span.passFail[data-content='pass'] { color: darkgreen; }
		span.passFail[data-content='pass']::before { color: darkgreen; content: "Pass"; }
		span.passFail[data-content='fail'] { color: darkred; }
		span.passFail[data-content='fail']::before { color: darkred; content:"Fail"; }

		div#svgTarget { width: fit-content; }
		div#svgTarget[transparentbg='true'] {
			background:  repeating-conic-gradient(#808080 0% 25%, transparent 0% 50%) 50% / 20px 20px;
		}

		.hide {
			display: none;
		}

		.borderify {
			padding: 0.5em;
			margin-top: 0.5em;
			border: 1px solid black;
		}

		body:not(.ignore-flexify) .flexify, .flexify.perma-flex {
			display: flex;
			align-items: center;
		}

		body:not(.ignore-flexify) .flexify > *, .flexify.perma-flex > * {
			margin-right: 1em;
		}
		
		body:not(.ignore-flexify) .flexify span, .flexify.perma-flex span {
			align-self: center;
		}

		body.ignore-flexify div#barcode-area {
			width: 60%;
		}

		body.ignore-flexify div#params {
			width: 35%;
		}

		body.ignore-flexify div#main-area {
			display: flex;
		}


		input[type="checkbox"]{
			width: 1.5em; height: 1.5em;
		}


		#logArea {
			min-height: 		2em;
			max-height: 		10em;
			border: 			1px solid black;
			padding: 			0.3em;
			white-space:		pre-wrap;
			overflow-y: scroll;
			word-break: break-word;
			word-wrap: break-word;
		}

		#logArea span.loggederror {
			color: red;
			font-weight: bold;
		}

		.optionContainer {
			border: 1px solid black;
			padding: 1em;
		}

		.pad-top {
			padding-top: 0.5em;
		}
	</style>
</html>
